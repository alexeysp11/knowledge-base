# WCF в .NET Core

## Обоснование перевода на .NET Core

Необходимость:
- Поддержка .NET Framework ограничена.
- .NET 6+ предоставляет новые возможности и улучшения языка.
- Поддержка старых технологий требует больших усилий и ресурсов в долгосрочной перспективе, поэтому обновление технологического стека является необходимым для любого бизнеса.

Исходя из этого, может возникнуть необходимость выбрать подходящую технологию для миграции WCF-сервиса на .NET Core.

## Официальная позиция Microsoft относительно WCF

В рамках .NET Core и .NET 5+, Microsoft частично отказалась от поддержки WCF: например, нет официальной библиотеки для создания серверных приложений WCF, однако существует библиотека [dotnet/wcf](https://github.com/dotnet/wcf) для создания клиентских приложений WCF, написанная в целях поддержания совместимости со старыми решениями WCF на .NET Framework.

Это связано с тем, что Microsoft стремится направить ресурсы на развитие современных технологий и отказаться от устаревающей кодовой базы .NET Framework. В качестве альтернативы WCF и SOAP, Microsoft активно продвигает идею перехода на другие способы коммуникации, в частности, Web API и gRPC. Среди основных причин такого решения выделяются следующие:

- **Устаревание .NET Framework и WCF:** Изначально WCF был создан для .NET Framework, который сейчас не является приоритетной платформой для Microsoft. В связи с этим, после выхода .NET 5, Microsoft отказался дальше развивать .NET Framework и многие другие технологии, которые использовались в рамках .NET Framework (в том числе WCF).
- **Универсальность HTTP и популярность RESTful API:** HTTP де-факто является стандартом для веб-коммуникаций и поддерживается всеми платформами. В связи с этим RESTful API, как архитектурный стиль, стал одним из самых популярных и удобных способов коммуникации между сервисами. В свою очередь, Web API позволяет крайне удобно создавать RESTful сервисы в рамках ASP.NET Core, поэтому Microsoft активно продвигает Web API.
- **Производительность gRPC:** gRPC является современным протоколом, основанным на HTTP/2, вследствии чего обеспечивает высокую производительность и эффективность, а также имеет много интересных функциональностей (стриминг данных, строгая типизация и автоматическая генерация кода). В официальной документации от Microsoft даже есть прямые рекомендации по переходу с WCF на gRPC (например, [gRPC for Windows Communication Foundation (WCF) developers](https://learn.microsoft.com/en-us/aspnet/core/grpc/why-migrate-wcf-to-dotnet-grpc) и [gRPC for WCF Developers](https://github.com/dotnet-architecture/eBooks/blob/1ed30275281b9060964fcb2a4c363fe7797fe3f3/current/grpc-for-wcf-developers/gRPC-for-WCF-Developers.pdf)).
- **Простота Web API и gRPC + интеграция с экосистемой ASP.NET Core:** Считается, что Web API и gRPC проще в понимании и использовании, чем WCF. Отчасти это связано с тем, что Web API и gRPC лучше интегрируются с современной экосистемой .NET.

**Выводы:**
- Фактически официальная позиция Microsoft относительно WCF заключается в том, что при разработке новых модулей на .NET желательно отказаться от WCF в пользу Web API и gRPC.
- Однако не всегда стоит отказываться от WCF в пользу Web API или gRPC без проведения дополнительного анализа, поскольку ситуация может оказаться сложнее и зависеть от ряда факторов: сложность самого сервиса, зависимости, согласование между командами. Например, можно сначала попробовать найти несколько популярных неофициальных альтернатив WCF и выбрать среди них наиболее подходящую.

### Случаи, когда стоит использовать gRPC вместо CoreWCF/SoapCore

- Производительность критична:
    - Если сервис должен обрабатывать большое количество запросов с минимальной задержкой, gRPC будет предпочтительнее. gRPC использует HTTP/2, бинарный формат Protobuf и имеет оптимизированные механизмы для сериализации/десериализации данных, что делает его гораздо более быстрым, чем SOAP (используется в WCF, CoreWCF и SoapCore).
- Микросервисная архитектура:
    - Если микросервисная архитектура и сервисы часто обмениваются данными внутри сети, gRPC идеально подходит из-за своей производительности и эффективного использования ресурсов.
- Внутренние коммуникации:
    - Если в основном сервисы общаются между собой (внутри одной организации), то gRPC более уместен, чем SOAP. SOAP более нацелен на интеграции между разными системами.
- Поддержка стриминга:
    - Если нужно поддерживать стриминг данных (например, передача больших файлов или потоков данных), gRPC подходит лучше, чем SOAP. gRPC имеет встроенную поддержку стриминга.
- Сильная типизация:
    - Если нужна строгая типизация и автоматическая генерация кода, gRPC с Protobuf - идеальный вариант. Protobuf позволяет тебе описать структуру данных, и на основе этих данных ты можешь автоматически сгенерировать клиентский и серверный код.
- Использование HTTP/2:
    - Если ты используешь HTTP/2 (либо планируешь это сделать), то тебе точно стоит выбрать gRPC, так как он основан на HTTP/2.
- Отсутствие legacy клиентов:
    - Если нет legacy клиентов, которые общаются с помощью WCF, то есть смысл посмотреть на gRPC.

### Случаи, когда стоит использовать Web API (HTTP) вместо CoreWCF/SoapCore

- RESTful архитектура:
    - Если есть потребность построить RESTful API, то Web API - это стандарт де-факто в мире .NET. Web API - это архитектурный стиль, который базируется на принципах HTTP.
- Интеграция с веб-приложениями:
    - Если сервис предназначен для интеграции с веб-приложениями, то Web API - это самый подходящий вариант, так как любой браузер (или приложение) может отправлять HTTP-запросы.
- Простота:
    - Если тебе нужна простота разработки и интеграции, то Web API - это более простой вариант. WCF (и его клоны) достаточно сложные в своей реализации.
- Внешние клиенты или публичный API:
    - Если сервис будет использоваться большим количеством разных внешних клиентов, то Web API - более уместен.
    - Если вы делаете публичный API, то Web API будет более распространенным и более понятным для других разработчиков.
- Универсальность и интеграция с другими сервисами:
    - HTTP является универсальным протоколом, который хорошо поддерживается на разных платформах и языках. Web API легко интегрируется с другими сервисами, основанными на HTTP (REST).
- Легкий вес:
    - Web API является легковесным и не требует больших ресурсов для своей работы.
- Легкая отладка:
    - HTTP запросы и ответы легко отлаживать с помощью браузера и dev tools.
- Микросервисы:
    - Если вы разрабатываете микросервисы, то Web API - твой выбор.

## Общие положения

На текущий момент Microsoft не предоставляет других официальных альтернатив для веб-разработки и сетевых приложений на .NET Core/.NET 6+, кроме ASP.NET Core. Поэтому при миграции WCF на более современные версии .NET рационально будет использовать решения, которые основываются именно на ASP.NET Core и инструментах, которые он предоставляет (например, Middleware, Dependency Injection и т.д.).

### Middleware как основа для построения WCF приложений на .NET Core

Middleware является довольно мощным инструментом в ASP.NET Core, который позволяет разделить ответственность между разными компонентами приложения, а также значительно упростить разработку и поддержку ПО.

В сущности, middleware в ASP.NET Core является **стадией обработки запроса**. Обычно каждый middleware выполняет следующие функции:
1. Получает HTTP-запрос от клиента.
2. Выполняет определенную задачу, например:
    - Проверяет авторизацию пользователя.
    - Логирует информацию о запросе.
    - Изменяет заголовки запроса.
    - Обрабатывает ошибки.
    - Преобразует данные.
    - Маршрутизирует запрос к нужному обработчику (контроллеру).
    - И многое другое.
3. После выполнения задачи он либо передает управление следующему middleware в конвейере обработки запроса, либо завершает обработку запроса и отправляет ответ клиенту (к примеру, ответ с ошибкой).

Как известно, WCF на .NET Framework работает с протоколом SOAP. В свою очередь, SOAP основывается на HTTP. Иначе говоря, в рамках HTTP-запроса передается XML-разметка, содержащая структурированные данные и служебную информацию, необходимую для взаимодействия с веб-сервисом. Из этого следует, что в любом WCF сервисе "под капотом" всегда будет обрабатываться HTTP запрос.

В результате, в .NET Core становится возможным реализовать middleware для работы с SOAP, т.е. такую стадию обработки HTTP запроса, которая бы имитировала основную работу WCF сервиса, написанного на .NET Framework (т.е. парсинг XML-разметки, извлечения данных и маршрутизации запроса к соответствующему обработчику/контроллеру). Например, аналогичный подход, связанный с использованием middleware, лежит в основе двух основных реализаций WCF на .NET Core: [CoreWCF](https://github.com/CoreWCF/CoreWCF) и [SoapCore](https://github.com/DigDes/SoapCore).

### Атрибуты `[ServiceContract]` и `[OperationContract]`

Атрибуты `[ServiceContract]` и `[OperationContract]` становятся крайне важными как в контексте получения WSDL, так и в процессе обработки запросов.

Для определения контракта сервиса в WCF используются атрибуты `[ServiceContract]` и `[OperationContract]` (см. классы [ServiceContractAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.servicemodel.servicecontractattribute) и [OperationContractAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.servicemodel.operationcontractattribute)). Эти атрибуты доступны также в .NET Core при установке пакета [System.ServiceModel.Primitives](https://www.nuget.org/packages/system.servicemodel.primitives/). На самом деле, эти классы становятся доступными в .NET Core благодаря вышеупомянутой библиотеке [dotnet/wcf](https://github.com/dotnet/wcf), предоставляющей в числе прочего официальные расширения для клиентских приложений WCF.

CoreWCF и SoapCore используют атрибуты `[ServiceContract]` и `[OperationContract]` примерно аналогичным образом. Данный код будет актуален как для CoreWCF, так и для SoapCore:
```C#
[ServiceContract]
public interface ISampleService
{
    [OperationContract]
    string Ping(string s);

    [OperationContract]
    int[] IntArray();

    [OperationContract]
    ComplexReturnModel[] ComplexReturnModel();
}

public class SampleService : ISampleService
{
    public string Ping(string s)
    {
        Console.WriteLine("Exec ping method");
        return s;
    }

    public int[] IntArray()
    {
        return new int[]
        {
            123,
            456,
            789
        };
    }

    public ComplexReturnModel[] ComplexReturnModel()
    {
        return new ComplexReturnModel[]
        {
            new ComplexReturnModel
            {
                Id = 1,
                Name = "Item 1"
            },
            new ComplexReturnModel
            {
                Id = 2,
                Name = "Item 2"
            }
        };
    }
}
```

#### Обработка запроса

Атрибуты `[ServiceContract]` и `[OperationContract]` используются как для генерации WSDL, так и в процессе обработки запросов для маршрутизации запроса к нужному экземпляру класса сервиса. Вот примерный план того, как происходит происходит обработка запроса:

1. **Получение SOAP-запроса**: Сервер получает SOAP-запрос от клиента.
2. **Парсинг SOAP-запроса**: Производится парсинг, чтобы определить:
    - **Имя сервиса**: Из `SOAPAction` заголовка или из содержимого сообщения извлекается имя сервиса, которое соответствует параметру `Name` для атрибута `[ServiceContract]`.
    - **Имя операции**: Из `SOAPAction` заголовка или из содержимого сообщения извлекается имя операции, которое соответствует параметру `Name` для атрибута `[OperationContract]`.
3. **Поиск соответствующего сервиса**: 
    - **CoreWCF**: CoreWCF использует механизм, основанный на `ServiceHost`, для регистрации сервисов. На основании имени сервиса он находит соответствующий тип, который реализует контракт (интерфейс с атрибутом `[ServiceContract]`). Этот тип обычно заранее зарегистрирован в `ServiceHost`.
    - **SoapCore**: SoapCore использует механизм, при котором при добавлении сервиса (`UseSoapEndpoint`) связывает endpoint с интерфейсом. На основании имени сервиса он находит соответствующий интерфейс, который реализует контракт (интерфейс с атрибутом `[ServiceContract]`).
4. **Создание экземпляра сервиса**: 
    - **CoreWCF**: CoreWCF может использовать свой внутренний DI-контейнер для создания экземпляра класса сервиса или может делегировать создание внешнему DI-контейнеру (например, встроенному в ASP.NET Core).
    - **SoapCore**: SoapCore полагается на DI-контейнер ASP.NET Core.
5. **Вызов операции**: 
    - Используя имя операции, найденное на этапе парсинга запроса, CoreWCF или SoapCore находят соответствующий метод в классе сервиса, помеченный атрибутом `[OperationContract]`.
    - Аргументы SOAP-запроса десериализуются в параметры метода.
    - Метод вызывается.
6. **Сериализация ответа**: Результат выполнения метода сериализуется обратно в SOAP-ответ.
7. **Отправка SOAP-ответа**: Сервер отправляет SOAP-ответ клиенту.

#### WSDL

WSDL (Web Services Description Language) представляет собой XML-документ, который описывает интерфейс веб-сервиса (SOAP).

Получение WSDL - это отдельный процесс, который происходит по запросу клиента (обычно HTTP GET-запрос к специальному URL, например `?wsdl`). Этот процесс включает в себя генерацию XML-описания сервиса (WSDL) на основе метаданных.

Генерация WSDL с использованием атрибутов `[ServiceContract]` и `[OperationContract]` производится согласно примерно следующему механизму:

1. **Получение HTTP GET-запроса на WSDL**: Клиент (например, svcutil или любое другое приложение, желающее узнать структуру сервиса) отправляет HTTP GET-запрос к специальному URL сервиса, например, с параметром `?wsdl`.

2. **Перехват запроса сервером**: серверное приложение перехватывает запрос, связанный с генерацией метаданных, в своем `ServiceHost` или middleware.

3. **Сбор метаданных**:
    - CoreWCF и SoapCore используют рефлексию для сканирования интерфейсов (сервисных контрактов), помеченных атрибутом `[ServiceContract]`, и методов, помеченных атрибутом `[OperationContract]`. Они анализируют:
        - Имя сервиса (из `[ServiceContract]` параметр `Name`).
        - Имя операций (из `[OperationContract]` параметр `Name`).
        - Типы параметров операций.
        - Возвращаемые типы.
        - Атрибуты `DataContract`, `DataMember`, и другие.

4. **Генерация WSDL**: На основе собранных метаданных формируется XML-документ WSDL, который описывает:
    - Типы данных, используемые в сервисе.
    - Структуру сообщений SOAP-запросов и SOAP-ответов.
    - Операции (методы) сервиса и их параметры.
    - Адреса привязок (endpoints) сервиса.
    - Используемые протоколы (SOAP, HTTP).

5. **Отправка WSDL**: Сервер отправляет сгенерированный XML-документ WSDL клиенту в качестве HTTP-ответа.

### Action Methods в CoreWCF/SoapCore

В ASP.NET Core термин "action method" используется для обозначения методов контроллера, которые обрабатывают запросы.

В WCF (как в .NET Framework, так и в CoreWCF) нет официального термина "action method".  Однако, в контексте CoreWCF, вполне допустимо использовать этот термин для обозначения методов, помеченных атрибутом `[OperationContract]` (или методов интерфейса, помеченного атрибутом `[ServiceContract]`) , которые обрабатывают запросы.

Поэтому хотя это не официальный термин, использование "action method" в разговоре о CoreWCF вполне допустимо и понятно, особенно для разработчиков, знакомых с ASP.NET Core. Главное, чтобы команда понимала, что имеется в виду.

## Сравнение CoreWCF vs SoapCore

### Простота на старте

**CoreWCF.** CoreWCF достаточно прост в контексте создания первого приложения в стиле Hello World. Стоит отметить также довольно хороший гайд по установке шаблонов и созданию первого приложения (установить шаблоны можно одной командой в терминале).

**SoapCore.** С другой стороны, SoapCore чуть сложнее в самом начале из-за того, что либо нет документации, либо она написана очень скупо. Поэтому пришлось сначала изучать сам репозиторий, в частности смотреть папку `samples` и пытаться реализовать аналогичную структуру проекта. Однако в контексте настройки первого приложения Hello World также нет особых сложностей, т.к. для запуска приложения достаточно `Program.cs`, `IService` и `Service` (где `IService` и `Service` - это интерфейс и класс для реализации сервиса, соответственно). На крайний случай, можно скопировать проект из папки `samples` и в дальнейшем изменять его под свои нужды.

### Поддержка Dependency Injection

**CoreWCF.** Как выяснилось впоследствии, легкость настройки - это только "видимость" простоты для CoreWCF на старте. Важно подчеркнуть, что сложность CoreWCF появляется в процессе работы, а именно при попытке использовать DI. Из-за того, что CoreWCF стремится во многом скопировать функционал WCF, там используется собственный DI-контейнер. На текущий момент я не разобрался, как этот DI-контейнер корректно использовать, чтобы, например, передать в конструктор сервиса нужный класс.

**SoapCore.** В свою очередь, SoapCore изначально создавался не как копия WCF на .NET Core, а как middleware для ASP.NET Core, способный обрабатывать SOAP (по словам разработчиков SoapCore, они вдохновлялись [данной статьей](https://devblogs.microsoft.com/dotnet/custom-asp-net-core-middleware-example/)). Поэтому SoapCore достаточно легко интегрируется в конвейер обработки запросов и не имеет особых проблем с Dependency Injection. Исходя из этого, он в целом лучше интегрируется в экосистему ASP.NET Core.

### Обратная совместимость

**CoreWCF.** CoreWCF поддерживает некоторые "устаревшие" фичи WCF (например, WS-ReliableMessaging), которых нет в SoapCore. Однако, на сегодняшний день CoreWCF также не полностью реализует все возможности WCF: некоторых фич не хватает или они реализованы не полностью.

**SoapCore.** Если используется большое количество нестандартных настроек WCF, то миграция на SoapCore может быть сложнее, и потребуется вручную реализовывать аналогичный функционал, т.к. SoapCore в основном ориентирован именно на протокол SOAP, а не на все возможности WCF (бинарные форматы, WS-, и т.д.). Однако с базовыми функциями WCF, SoapCore справляется достаточно хорошо.

### Архитектура

**CoreWCF.** Непонимание того, как корректно использовать Dependency Injection в CoreWCF может привести к тому, что используются специфичные способы управления зависимостями: например, когда один и тот же класс (зависимость) одновременно инициализируется/сохраняется как с помощью DI-контейнера, так и с помощью статического класса, что может вызвать проблемы в архитектуре.

**SoapCore.** Как уже было отмечено, SoapCore имеет более простую и прозрачную архитектуру, основанную на принципах ASP.NET Core middleware, что делает ее более понятной и легкой для использования в ASP.NET Core. Поэтому, если предолагается использовать только базовые возможности WCF, то в контексте архитектуры SoapCore может быть более предпочтительным.

### Чувствительность к регистру

**По умолчанию WCF чувствителен к регистру** при парсинге наименований параметров, как для параметров в URL, так и в SOAP/XML. То есть `/MyService/DoSomething?param1=value` будет отличаться от `/MyService/dosomething?Param1=value`. Однако это поведение может быть изменено с помощью пользовательских биндингов и расширений.

**CoreWCF и SoapCore по умолчанию также чувствительны к регистру** при парсинге имен параметров, это поведение унаследовано от WCF. Если вы будете использовать basicHttpBinding, то CoreWCF/SoapCore будет работать точно также, как и WCF на .NET Framework. То есть, метод `[OperationContract] void DoSomething(int param1)` будет ожидать параметра именно с именем `param1`, и передача `Param1` приведет к ошибке или необработке этого параметра.

Добиться того, чтобы параметры action-методов в CoreWCF были независимы от регистра, **теоретически возможно**, однако это может требовать существенных доработок: https://github.com/CoreWCF/CoreWCF/discussions/1346.

### Выводы

Основываясь на результатах исследования, если используются базовые функции WCF, то SoapCore представляет собой более подходящий вариант для миграции WCF-сервиса на .NET 6+ (в контексте архитектуры и интеграции с ASP.NET Core). Однако если требуются более специфичные функции WCF (бинарные форматы, WS-, и т.д.), то CoreWCF будет предоставлять чуть больший диапазон возможностей.

Я бы рекомендовал выбрать SoapCore для сервиса WCF, но для этого необходимо провести тестирование производительности и сделать прототип в реальных условиях.
