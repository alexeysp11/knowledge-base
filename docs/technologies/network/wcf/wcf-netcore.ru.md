# WCF в .NET Core

## Обоснование перевода на .NET Core

Необходимость:
- Поддержка .NET Framework ограничена.
- .NET 6+ предоставляет новые возможности и улучшения языка.
- Поддержка старых технологий требует больших усилий и ресурсов в долгосрочной перспективе, поэтому обновление технологического стека является необходимым для любого бизнеса.

Исходя из этого, может возникнуть необходимость выбрать подходящую технологию для миграции WCF-сервиса на .NET Core.

## Официальная позиция Microsoft относительно WCF

Microsoft постепенно отходит от WCF и продвигает Web API (HTTP) и gRPC. Среди основных причин можно выделить:

- **Устаревание WCF:** WCF создан для .NET Framework, и Microsoft отказался дальше его развивать.
- **Универсальность HTTP:** HTTP является универсальным протоколом, который хорошо поддерживается всеми платформами.
- **Производительность gRPC:** gRPC - это современный протокол, основанный на HTTP/2, который обеспечивает высокую производительность и эффективность.
- **Простота Web API и gRPC:** Web API и gRPC проще в понимании и использовании, чем WCF.
- **Экосистема:** Web API и gRPC лучше интегрируются с современной экосистемой .NET и облачными технологиями.

Имея в виду официальную позицию Microsoft относительно WCF, в некоторых случаях также имеет смысл рассмотреть переход на Web API (HTTP) и gRPC.

## Общие положения

### Атрибуты `[ServiceContract]` и `[ServiceOperation]` в контексте получения WSDL

WSDL (Web Services Description Language) - это XML-документ, который описывает интерфейс веб-сервиса (SOAP).

Соответственно, атрибуты `[ServiceContract]` и `[ServiceOperation]` используются для генерации WSDL согласно следующему механизму:

- Атрибуты предоставляют **метаданные** о сервисе, необходимые для генерации WSDL: имя сервиса, имя операции, параметры, типы данных, и т.д.
- Обе библиотеки (CoreWCF и SoapCore) используют **reflection** для сканирования интерфейсов и методов, помеченных этими атрибутами, и на основе этой информации генерируют WSDL.
- Клиент может использовать этот WSDL для создания прокси-классов и автоматического вызова операций сервиса.

### Action Methods в CoreWCF/

В ASP.NET Core термин "action method" используется для обозначения методов контроллера, которые обрабатывают запросы.

В WCF (как в .NET Framework, так и в CoreWCF) нет официального термина "action method".  Однако, в контексте CoreWCF, вполне допустимо использовать этот термин для обозначения методов, помеченных атрибутом `[ServiceOperation]` (или методов интерфейса, помеченного атрибутом `[ServiceContract]`) , которые обрабатывают запросы.

Поэтому хотя это не официальный термин, использование "action method" в разговоре о CoreWCF вполне допустимо и понятно, особенно для разработчиков, знакомых с ASP.NET Core. Главное, чтобы команда понимала, что имеется в виду.

### Чувствительность к регистру

- **WCF (.NET Framework)**:
    - По умолчанию WCF чувствителен к регистру при парсинге наименований параметров, как для параметров в URL, так и в SOAP/XML. То есть `/MyService/DoSomething?param1=value` будет отличаться от `/MyService/DoSomething?Param1=value`.
    - Это поведение может быть изменено с помощью пользовательских биндингов и расширений, но стандартное поведение подразумевает чувствительность.
- **CoreWCF**:
    - CoreWCF *по умолчанию чувствителен к регистру* при парсинге имен параметров. Это поведение унаследовано от WCF.
    - Если вы будете использовать basicHttpBinding, то CoreWCF будет работать точно также, как и WCF на .NET Framework.
        - То есть, `[OperationContract] void DoSomething(int param1)` будет ожидать параметра именно с именем `param1`, и передача `Param1` приведет к ошибке или необработке этого параметра.
    - Также, как и в классическом WCF, это поведение может быть изменено.
    - Добиться того, чтобы параметры action-методов были независимы от регистра, **теоретически возможно**, однако требует существенных доработок: https://github.com/CoreWCF/CoreWCF/discussions/1346.
- **SoapCore**:
    - SoapCore также по умолчанию чувствителен к регистру при парсинге имен параметров.

## Анализ исследования

### Простота на старте

CoreWCF достаточно прост в контексте создания первого приложения в стиле Hello World. Стоит отметить также довольно хороший гайд по установке шаблонов и созданию первого приложения (установить шаблоны можно одной командой в терминале).

С другой стороны, SoapCore чуть сложнее в самом начале из-за того, что либо нет документации, либо она написана очень скупо. Поэтому пришлось сначала изучать сам репозиторий, в частности смотреть папку `samples` и пытаться реализовать аналогичную структуру проекта. Однако в контексте настройки первого приложения Hello World также нет особых сложностей, т.к. для запуска приложения достаточно `Program.cs`, `IService` и `Service` (где `IService` и `Service` - это наименование сервиса). На крайний случай, можно скопировать проект из папки `samples` и в дальнейшем изменять его под свои нужды.

### Поддержка Dependency Injection

Как выяснилось впоследствии, легкость настройки - это только "видимость" простоты для CoreWCF на старте. Важно подчеркнуть, что сложность CoreWCF появляется в процессе работы, а именно при попытке использовать DI. Из-за того, что CoreWCF стремится полностью скопировать функционал WCF, он официально не поддерживает перегрузку конструкторов для класса, реализующего функционал сервиса. В результате, несмотря на то, что CoreWCF работает внутри ASP.NET Core приложения, он при этом не поддерживает одну из основных функциональностей ASP.NET Core - Dependency Injection. Из-за этого ограничения в CoreWCF требуется использовать статичные классы для хранения зависимостей, что усложняет разработку.

В свою очередь, SoapCore изначально создавался не как копия WCF на .NET Core, а как middleware для ASP.NET Core, способный обрабатывать SOAP. Поэтому SoapCore достаточно легко интегрируется в конвейер обработки запросов и не имеет особых проблем с Dependency Injection. Исходя из этого, он в целом лучше интегрируется в экосистему ASP.NET Core.

### Обратная совместимость

CoreWCF поддерживает некоторые "устаревшие" фичи WCF (например, WS-ReliableMessaging), которых нет в SoapCore. Однако, на сегодняшний день CoreWCF также не полностью реализует все возможности WCF: некоторых фич не хватает или они реализованы не полностью.

Если используется большое количество нестандартных настроек WCF, то миграция на SoapCore может быть сложнее, и потребуется вручную реализовывать аналогичный функционал, т.к. SoapCore в основном ориентирован именно на протокол SOAP, а не на все возможности WCF (бинарные форматы, WS-, и т.д.).

### Архитектура

Как уже было отмечено, отсутствие поддержки Dependency Injection в CoreWCF "из коробки" может требовать использование статических классов для хранения зависимостей, что "выключает" одну из основных функций ASP.NET Core. В результате может получиться, что один и тот же класс (зависимость) одновременно инициализируется/сохраняется как с помощью DI-контейнера, так и с помощью статического класса, что может вызвать проблемы в архитектуре.

Как уже было отмечено, SoapCore имеет более простую и прозрачную архитектуру, основанную на принципах ASP.NET Core middleware, что делает ее более понятной и легкой для использования в ASP.NET Core. Поэтому, если предолагается использовать только базовые возможности WCF, то в контексте архитектуры SoapCore может быть более предпочтительным.

### Выводы

Основываясь на результатах исследования, SoapCore представляет собой более подходящий вариант для миграции WCF-сервиса на .NET 6+ в контексте архитектуры. Однако если требуются более специфичные функции WCF (бинарные форматы, WS-, и т.д.), то CoreWCF будет предоставлять чуть больший диапазон возможностей.

Хотя CoreWCF может казаться более простым на начальном этапе из-за своей схожести с оригинальным WCF, он не обеспечивает полноценной поддержки DI, что усложняет разработку и тестирование. SoapCore, будучи middleware ASP.NET Core, предлагает полноценную интеграцию с DI, более простую архитектуру и легкую разработку.

Я бы рекомендовал выбрать SoapCore для сервиса WCF, но для этого необходимо провести тестирование производительности и сделать прототип в реальных условиях.
