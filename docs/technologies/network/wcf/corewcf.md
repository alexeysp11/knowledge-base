# CoreWCF

## Action Methods в CoreWCF

- В ASP.NET Core термин "action method" используется для обозначения методов контроллера, которые обрабатывают запросы.
- В WCF (как в .NET Framework, так и в CoreWCF) нет официального термина "action method".  Однако, в контексте CoreWCF, вполне допустимо использовать этот термин для обозначения методов, помеченных атрибутом `[ServiceOperation]` (или методов интерфейса, помеченного атрибутом `[ServiceContract]`) , которые обрабатывают запросы.
- Вывод: Хотя это не официальный термин, использование "action method" в разговоре о CoreWCF вполне допустимо и понятно, особенно для разработчиков, знакомых с ASP.NET Core. Главное, чтобы команда понимала, что имеется в виду.

## Чувствительность к регистру в WCF (и CoreWCF)

- WCF (.NET Framework):
    - По умолчанию WCF чувствителен к регистру при парсинге наименований параметров, как для параметров в URL, так и в SOAP/XML. То есть `/MyService/DoSomething?param1=value` будет отличаться от `/MyService/DoSomething?Param1=value`.
    - Это поведение может быть изменено с помощью пользовательских биндингов и расширений, но стандартное поведение подразумевает чувствительность.
- *CoreWCF:*
    - CoreWCF *по умолчанию чувствителен к регистру* при парсинге имен параметров. Это поведение унаследовано от WCF.
    - Если вы будете использовать basicHttpBinding, то CoreWCF будет работать точно также, как и WCF на .NET Framework.
        - То есть, `[OperationContract] void DoSomething(int param1)` будет ожидать параметра именно с именем `param1`, и передача `Param1` приведет к ошибке или необработке этого параметра.
    - Также, как и в классическом WCF, это поведение может быть изменено.

Добиться того, чтобы параметры action-методов были независимы от регистра, **теоретически возможно**: https://github.com/CoreWCF/CoreWCF/discussions/1346.

## Авторизация

### Базовая Авторизация: Preemptive vs Non-Preemptive

- **Preemptive Authorization**:
    - **Цель**: Отправлять учетные данные (логин и пароль) в заголовке HTTP-запроса сразу при первом запросе, даже не получая от сервера ответа `401 Unauthorized`.
    - **Плюсы**:
        - Меньше сетевых задержек: сервер обрабатывает запрос сразу, не нужно дважды обращаться к серверу.
    - **Минусы**:
        - Уязвимость безопасности: учетные данные передаются без предварительного запроса и могут быть перехвачены.
        - Сложность в управлении: для каждого запроса нужно явно добавлять заголовок авторизации.
    - **Вывод**: Preemptive обычно используется в случаях, когда необходимо повысить производительность при очень большом количестве запросов, но это сопряжено с большими рисками безопасности. Но даже в этих случаях её стараются избегать.

- **Non-Preemptive Authorization**:
    - **Цель**: Отправлять учетные данные только после получения от сервера ответа `401 Unauthorized`.
    - **Плюсы**:
        - Безопасность: учетные данные не передаются, если сервер не требует авторизации.
        - Простота: как правило, браузеры/клиенты автоматически обрабатывают ответ `401` и повторно отправляют запрос с заголовком авторизации.
    - **Минусы**:
        - Лишний запрос: требует два обращения к серверу (сначала без, потом с учетными данными).
