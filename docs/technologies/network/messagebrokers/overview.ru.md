# Обзор характеристик брокеров сообщений

Современные организации имеют различные конвейеры данных, которые облегчают связь между системами или службами. Все становится немного сложнее, когда разумному количеству служб необходимо взаимодействовать друг с другом в режиме реального времени.

Архитектура становится сложной, поскольку для обеспечения взаимодействия этих служб требуются различные интеграции. Точнее, для архитектуры, которая охватывает m исходных и n целевых служб, необходимо написать n x m различных интеграций. Кроме того, каждая интеграция поставляется с другой спецификацией, что означает, что может потребоваться другой протокол (HTTP, TCP, JDBC и т. д.) или другое представление данных (двоичное, Apache Avro, JSON и т. д.), что еще больше усложняет задачу. Кроме того, исходные службы могут решать проблему возросшей нагрузки от соединений, которая может потенциально повлиять на задержку.s

- https://stackoverflow.com/questions/42151544/when-to-use-rabbitmq-over-kafka/42154452#42154452
- https://stackoverflow.com/questions/13647423/nservicebus-vs-masstransit/13660712#13660712

## Общий анализ брокеров сообщений

### RabbitMQ

Популярный, легковесный брокер, поддерживает различные модели обмена сообщениями.

RabbitMQ - это традиционный брокер сообщений общего назначения. Он позволяет веб-серверам быстро отвечать на запросы и доставлять сообщения нескольким службам. Publishers могут публиковать сообщения и делать их доступными для очередей, чтобы consumers могли их извлекать. Коммуникация может быть как асинхронной, так и синхронной.

Наиболее очевидный вариант использования, когда вам следует предпочесть RabbitMQ (или любую технологию очереди) вместо Kafka, следующий:

У вас есть несколько потребителей, потребляющих из очереди, и всякий раз, когда в очереди появляется новое сообщение и есть доступный потребитель, вы хотите, чтобы это сообщение было обработано. Если вы внимательно посмотрите на то, как работает Kafka, вы заметите, что он не знает, как это сделать, из-за масштабирования разделов у вас будет потребитель, выделенный для раздела, и вы столкнетесь с [starvation issue](https://en.wikipedia.org/wiki/Starvation_(computer_science), когда процессу постоянно отказывают в необходимых ресурсах для обработки его работы). Проблему, которую легко избежать, используя простую технологию очереди. Вы можете подумать об использовании потока, который будет отправлять разные сообщения из одного и того же раздела, но, опять же, у Kafka нет никаких механизмов выборочного подтверждения.

### Kafka

Высокопроизводительный брокер, оптимизированный для обработки потоковых данных.

Apache Kafka — это не просто брокер сообщений. Изначально он был разработан и реализован LinkedIn для работы в качестве очереди сообщений. С 2011 года Kafka стал open-source и быстро превратился в распределенную потоковую платформу, которая используется для реализации конвейеров данных в реальном времени и потоковых приложений.

Одно важное отличие заключается в том, что RabbitMQ — это система обмена сообщениями на основе push, тогда как Kafka — это система обмена сообщениями на основе pull. Это важно в сценариях, где система обмена сообщениями должна удовлетворять разнородные типы потребителей с различными возможностями обработки. С системой на основе Pull потребитель может потреблять на основе своих возможностей, тогда как push-системы будут отправлять сообщения независимо от состояния потребителя, что тем самым может подвергать потребителя высокому риску.

### ActiveMQ

Универсальный брокер, поддерживает множество протоколов и функций.

### NServiceBus

Ссылки: [репозиторий](https://github.com/Particular/NServiceBus)

Популярный open-source брокер сообщений на C#, предоставляет широкие возможности для создания распределенных систем.

Есть мнение, что [NServiceBus](https://github.com/Particular/NServiceBus) и [MassTransit](https://github.com/MassTransit/MassTransit) лучше всего рассматривать как промежуточное программное обеспечение, которое располагается поверх инфраструктуры обмена сообщениями, такой как RabbitMQ, Azure Service Bus или Kafka.

### MassTransit

Ссылки: [Википедия](https://en.wikipedia.org/wiki/MassTransit-Project), [репозиторий](https://github.com/MassTransit/MassTransit)

Еще один популярный open-source брокер на C#, известен своей гибкостью и поддержкой различных транспортных протоколов.

### Redis

Некоторые считают Redis брокером, но у него есть свои особенности.

Аргументы, почему Redis считают брокером сообщений:

- **Высокая производительность**: Redis известен своей скоростью, что может быть преимуществом для брокеров сообщений.
- **Простая реализация**: Redis относительно прост в установке и использовании, что делает его привлекательным для быстрого прототипирования.
- **Поддержка различных функций**: Redis предоставляет функции для кэширования, публикации/подписки, что может быть полезным для брокера сообщений.

Аргументы, почему Redis не может быть назван полноценным брокером сообщений:

- **Не предназначен исключительно для брокеров сообщений**: Redis - это в первую очередь кэширующий сервер, а не полноценный брокер сообщений.
- **Отсутствие некоторых функций**: Redis не поддерживает все функции брокеров сообщений, такие как долговечность, транзакционность, распределенные транзакции.
- **Ограниченные возможности**: Redis не подходит для обработки больших объемов данных, поскольку он хранит данные в оперативной памяти.

Redis может быть использован как брокер сообщения, но имеет ограничения. Он подходит для простых сценариев, где важна скорость и простота, но не подходит для сложных систем, где требуется высокая надежность и масштабируемость.

## Критерии сравнения:

- Производительность: Скорость обработки и передачи сообщений.
- Масштабируемость: Способность обрабатывать возрастающий объем данных и количество клиентов.
- Долговечность: Способность сохранять сообщения при сбоях и восстановлении данных.
- Функциональность: Поддержка различных моделей обмена сообщениями, таких как публикация/подписка, очередь сообщений, транзакции.
- Безопасность: Защита данных от несанкционированного доступа и модификации.
- Простота использования: Удобство установки, конфигурирования и использования брокера.
- Сообщество: Размер и активность сообщества, предоставляющего поддержку и документацию.

## Выбор брокера по языку программирования

Язык программирования иногда может влиять на выбор брокера. Но это не означает, что вы должны выбирать брокер, написанный на том же языке, что и ваше приложение.

- Поддержка: Важно убедиться, что брокер имеет хорошую поддержку для вашего языка программирования, включая клиентские библиотеки и документацию.
- Экосистема: Помимо языка программирования, важно учитывать экосистему брокера, такую как дополнительные инструменты, плагины и библиотеки.

## Изучение документации клиентов для работы с брокерами сообщений

Может быть полезно разбираться в клиентах для каждого брокера. Клиентские библиотеки предоставляют интерфейс для взаимодействия с брокером, поэтому важно понять, как они работают.

- Изучение API: Изучите API клиентской библиотеки, чтобы понять, как отправлять и получать сообщения.
- Тестирование: Проведите тесты, чтобы убедиться, что клиентские библиотеки работают корректно.
