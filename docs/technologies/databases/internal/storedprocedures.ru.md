# Хранимые процедуры 

## Архитектурные подходы, оправдывающие хранимые процедуры

Очень часто выбор того или иного архитектурного решения на реальном проекте продиктован не компетенцией конкретного программиста или архитектора ПО, а требованиями со стороны бизнеса (например, сократить время/стоимость разработки и поддержки ПО).
Среди архитектурных подходов, оправдывающих хранимые процедуры, можно выделить следующие:

- **Low-code/no-code платформы**: Действительно, многие платформы такого типа полагаются на хранимые процедуры, чтобы скрыть сложность SQL и предоставить пользователям простой визуальный интерфейс для создания бизнес-логики. 
- **Микросервисная архитектура**: При использовании микросервисов хранимые процедуры могут быть полезны для разделения логики доступа к данным и предоставления изоляции между сервисами.
- **Системы с ограниченными ресурсами**: В некоторых системах с ограниченными вычислительными ресурсами (например, встраиваемые системы) хранимые процедуры могут быть более эффективными, так как они выполняются на сервере базы данных, а не на клиентском устройстве.
- **Системы с высокой нагрузкой**: Хранимые процедуры могут быть более эффективными в обработке больших объемов данных, поскольку они выполняются на сервере базы данных, который оптимизирован для этой задачи.

## Способы организации бизнес-логики и работы с данными

- **Компилируемый код + ORM (Object-Relational Mapper)**: В этом случае бизнес-логика реализована на языке программирования (например, Java, Python), а ORM используется для преобразования объектов в SQL-запросы.
- **Компилируемый код + SQL**: Здесь бизнес-логика также реализована на языке программирования, но SQL-запросы пишутся вручную.
- **Веб-сервисы**: В этом случае бизнес-логика реализована на сервере, который принимает запросы от клиентов и отправляет ответы, взаимодействуя с базой данных через SQL или ORM.
- **Хранимые процедуры**: Как вы уже знаете, хранимые процедуры хранятся на сервере базы данных и выполняются непосредственно на нем.

### Хранимые процедуры

#### Плюсы хранимых процедур

- **Повышение производительности**: Хранимые процедуры компилируются и выполняются на сервере базы данных, что может быть значительно быстрее, чем выполнение запросов с клиента.
- **Сокращение сетевого трафика**: Хранимые процедуры сокращают количество запросов, отправляемых на сервер базы данных, что снижает нагрузку на сеть.
- **Повышение безопасности**: Хранимые процедуры могут быть защищены с помощью политик безопасности, чтобы ограничить доступ к ним.
- **Упрощение описания архитектуры при проектировании и определения зон ответственности**: Хранимые процедуры могут быть использованы для отделения бизнес-логики от кода приложения, что упрощает разработку и поддержку.
- **Совместное использование логики (при условии атомарности хранимых процедур)**: Хранимые процедуры могут быть использованы повторно в разных частях приложения.
- **Повышение гибкости (в контексте модульности приложения)**: Хранимые процедуры могут быть изменены без изменения кода приложения.
- **Управление доступом к данным**: Хранимые процедуры могут быть использованы для управления доступом к данным, обеспечивая безопасность данных.
- **Оптимизация запросов**: Сервер базы данных может оптимизировать хранимые процедуры для достижения максимальной производительности.
- **Управление транзакциями**: Хранимые процедуры могут быть использованы для управления транзакциями, что обеспечивает целостность данных.
- **Сокращение ошибок**: Хранимые процедуры могут сократить количество ошибок в коде приложения, так как они выполняются на сервере базы данных, который оптимизирован для работы с данными. Например, к таким ошибкам можно отнести ошибки при конвертации типов.

#### Минусы хранимых процедур

- **Сложность отладки**: Отладка хранимых процедур может быть сложнее, чем отладка кода приложения.
- **Отсутствие гибкости (в контексте использования объектных моделей и особенностей языка программирования)**: Хранимые процедуры могут быть менее гибкими, чем код приложения, так как они ограничены языком SQL. По этой же причине хранимые процедуры могут быть трудны в поддержке.
- **Проблемы с переносимостью**: Хранимые процедуры могут быть не переносимыми между различными системами управления базами данных.
- **Проблемы с тестированием**: Тестирование хранимых процедур может быть более сложным, чем тестирование кода приложения.
- **Проблемы с версионированием**: Версионирование хранимых процедур может быть затруднено, однако это может быть решено с помощью систем управления версиями.
- **Проблемы с повторным использованием**: Хранимые процедуры могут порождать сложности для повторного использования в других приложениях за счет того, что хранимые процедуры зачастую специфичны под конкретных бизнес-кейсов. В результате этого хранимые процедуры могут стать узким местом при масштабировании приложения или интеграции с другими системами.

### Компилируемый код + ORM

#### Плюсы использования компилируемый код + ORM

- **Повторное использование кода**: ORM позволяет повторно использовать код, который не зависит от конкретной базы данных.
- **Удобство в работе**: Многие разработчики отмечают, что ORM предлагает более удобный способ работы с базой данных, чем SQL. Хотя вопрос удобства в данном контексте может быть дискуссионным.
- **Контроль структуры таблиц на уровне компиляции**: ORM во многих случаях позволяет уже на уровне компиляции кода убедиться в том, что структура таблиц и зависимости между таблицами прописаны корректно.
- **Легкая отладка**: Отладка кода приложения с использованием ORM более удобна.
- **Тестирование**: Тестирование кода приложения с использованием ORM более удобно (например, за счет мок-классов и стабов).
- **Совместимость с различными базами данных**: ORM может работать с различными базами данных.
- **Упрощение интеграции**: ORM упрощает интеграцию с другими системами за счет использования общей кодовой базы и объектной модели.
- **Локальное повышение производительности**: ORM может оптимизировать SQL-запросы за счет кэширования, использования индексов и других оптимизаций для повышения производительности.
- **Упрощение разработки (за счет ограничения деталей, которые необходимо контролировать)**: ORM упрощает разработку, позволяя разработчикам сосредоточиться на бизнес-логике, а не на деталях SQL.
- **Улучшение качества кода**: Многие разработчики отмечают, что ORM может улучшить качество кода, делая его более читаемым и понятным.

#### Минусы использования компилируемый код + ORM

- **Потери производительности**: ORM может быть менее эффективным, чем прямые SQL-запросы.
- **Усложнение архитектуры**: ORM может усложнить архитектуру приложения, добавляя дополнительный уровень абстракции.
- **Зависимость от ORM**: Приложение становится зависимым от конкретной реализации ORM.
- **Ограничения в работе с базой данных**: ORM может ограничивать возможности работы с базой данных.
- **Сложность в отладке запросов**: Отладка сложных запросов, генерируемых ORM, может быть сложной. Сложность возникает, когда ORM генерирует очень сложные SQL-запросы, которые трудно прочитать и понять. В таком случае отладка становится затруднительной, так как нужно разобраться в логике ORM и понять, как он генерирует запросы.
- **Проблемы с производительностью при большом объеме данных**: ORM может создавать проблемы с производительностью при работе с большим объемом данных. ORM может создавать проблемы с производительностью при работе с большим объемом данных, так как дополнительные операции ORM могут замедлять работу приложения.
- **Усложнение тестирования**: Тестирование кода приложения с использованием ORM может быть более сложным. В некоторых случаях тестирование с ORM может быть более сложным, чем с прямыми SQL-запросами, особенно когда ORM генерирует сложные запросы, которые трудно протестировать. Также может возникнуть необходимость в тестировании ORM самостоятельно, что добавляет дополнительную сложность.
- **Увеличение времени разработки**: ORM может увеличить время разработки, так как разработчики должны изучить и использовать его API, а также спроектировать объектную модель.

### Компилируемый код + SQL

#### Плюсы использования компилируемый код + SQL

- **Хорошая гибкость**: SQL обеспечивает максимальную гибкость в работе с базой данных.
- **Полный контроль над запросами и оптимизацией**: SQL предоставляет полный контроль над запросами, что позволяет оптимизировать их для достижения максимальной производительности. Прямое использование SQL позволяет оптимизировать запросы вручную.
- **Повышение производительности**: Прямые SQL-запросы могут быть более эффективными, чем запросы, генерируемые ORM (при условии того, что разработчик понимает принципы оптимизирования SQL-запросов).
- **Совместимость с различными базами данных**: SQL является стандартным языком для работы с базами данных. За счет этого SQL легко интегрируется с другими системами.
- **Сокращение затрат**: Не требует использования сторонних библиотек.

#### Минусы использования компилируемый код + SQL:

- **Сложность в работе**: SQL может требовать дополнительных усилий для изучения и использования.
- **Повышенная вероятность ошибок**: Ручное написание SQL-запросов повышает вероятность ошибок.
- **Недостаток абстракции**: Отсутствие абстракции в SQL может усложнить разработку приложения, так как разработчики должны будут отслеживать детали взаимодействия с базой данных и писать более низкоуровневый код.
- **Сложность в поддержке**: SQL-запросы могут быть сложными для поддержки, если они не документированы или не структурированы. Также может быть сложно найти необходимый запрос в большом количестве кода приложения.  
- **Проблемы с повторным использованием кода**: SQL-запросы не всегда можно легко повторно использовать.
- **Проблемы с переносимостью**: SQL-запросы могут быть не переносимыми между различными базами данных: SQL является стандартным языком для работы с базами данных, но он имеет множество диалектов, которые отличаются в синтаксисе и функциональности.
- Проблемы с тестированием: Тестирование SQL-запросов может быть более сложным, чем тестирование кода приложения.
- **Проблемы с версионированием**: Версионирование SQL-запросов может быть затруднено (особенно, если запросы определены напрямую в коде).

## Когда оправдан перенос бизнес-логики в хранимые процедуры:

- **Высокие требования к производительности**: Хранимые процедуры могут значительно увеличить скорость выполнения запросов.
- **Повышение безопасности**: Хранимые процедуры ограничивают доступ к данным, предоставляя пользователям только те права, которые необходимы для работы с ними.
- **Упрощение разработки**: Хранимые процедуры могут упростить разработку приложения, позволяя разделить бизнес-логику от кода приложения.
- **Совместное использование логики**: Хранимые процедуры можно использовать повторно в разных частях приложения.
- **Обеспечение конфиденциальности данных**: Хранимые процедуры могут быть использованы для защиты чувствительных данных.

Выбор архитектурного подхода для организации бизнес-логики и работы с данными зависит от конкретных требований приложения. Хранимые процедуры могут быть полезным инструментом, если приложение требует высокой производительности, безопасности и упрощения разработки. Однако, если приложение требует большей гибкости, переносимости и удобства разработки, компилируемый код с использованием ORM или SQL может быть более подходящим выбором. 

Важно отметить, что правильный выбор архитектурного подхода зависит от конкретных потребностей проекта.

## Introduction

Ситуация, когда большая часть логики находится в хранимых процедурах, может быть связана со следующими причинами:
- особенности платформы ([ссылка на пример](https://wfsys.gitbook.io/workflow-engine-syntax/workflow_engine/sql_queries/sql_query): внутри тэга `Text` предполагается писать SQL-запрос):
```XML
<SqlQuery Name="">
  <Updates>
    <Update TableName="" Type="" Parameter="" OnlyLast="" />
  </Updates>
  <Events>
    <Event Name="">
      <Parameters>
        <Parameter Name=""></Parameter>
      </Parameters>
    </Event>
  </Events>
  <Text></Text>
</SqlQuery>
```
- если система написана давно, и перенос бизнес-логики в ООП модель оказывается дороже, чем поддержание бизнес-логики в хранимых процедурах.

## Хранимые процедуры vs ORM/ООП

Хранимые процедуры увеличивают скорость работы с данными, но являются менее динамичными в плане изменения/гибкости бизнес-логики по сравнению с ORM и парадигмой ООП.

Кроме того, среди негативных сторон процедур можно отметить: 
- Сложность в документировании, в т.ч. из-за недостаточной выразительности SQL в контексте описания бизнес-логики.
- Сложность/невозможность юнит-тестирования.
- БД часто рассматривается как наименее расширяемая часть (например, в контексте бизнес-логики, как сказано выше).

[Pros and Cons of holding all the business logic in stored procedures in web application](https://softwareengineering.stackexchange.com/questions/158534/pros-and-cons-of-holding-all-the-business-logic-in-stored-procedures-in-web-appl)

## Портирование бизнес-логики из хранимых процедур 

Один из примеров удачного комбинирования хранимых процедур с ORM является, например, **получение отделов пользователя в ELMA**: 
- на уровне ORM: метод [PublicAPI.Portal.Security.User.GetUserDepartments()](https://kb.elma-bpm.com/help_api/version/3.9.0/en_US/html/M_EleWise_ELMA_API_PublicAPI_PortalApiRoot_SecurityPortalApi_UserSecurityApi_GetUserDepartments.htm):
```C#
public IEnumerable<OrganizationItem> GetUserDepartments(
	User user
)
```
- на уровне БД: `getusersdepartments()` (актуально для PostgreSQL) - возвращает [таблицу ассоциаций](https://en.wikipedia.org/wiki/Associative_entity).

При работе с запросами, использующими хранимые процедуры или триггеры, могут возникнуть следующие проблемы:
- Замедление процессов из-за необходимости выполнения хранимых процедур или триггеров.
- Неэффективное использование ресурсов из-за создания большого количества хранимых процедур или триггеров.
- Проблемы с обновлением и резервным копированием БД из-за необходимости учета хранимых процедур и триггеров.

**Причины для переноса:**

* **Улучшение  тестируемости:**  Компилируемый  код  легче  тестировать,  чем  хранимые  процедуры.
* **Повышение  гибкости  и  переносимости:**  Компилируемый  код  легче  изменить  и  перенести  на  другую  платформу.
* **Упрощение  отладки:**  Компилируемый  код  проще  отлаживать,  чем  хранимые  процедуры.
* **Улучшение  читаемости  и  поддерживаемости:**  Компилируемый  код  часто  более  читаемый  и  легче  поддерживать.
* **Упрощение  интеграции  с  другими  системами:**  Компилируемый  код  легче  интегрировать  с  другими  системами.
* **Повышение  производительности:**  В  некоторых  случаях  компилируемый  код  может  быть  более  производительным,  чем  хранимые  процедуры.
* **Упрощение  разработки:**  Компилируемый  код  может  упростить  разработку,  так  как  разработчики  могут  использовать  более  мощные  языки  программирования.
* **Улучшение  безопасности:**  Компилируемый  код  может  улучшить  безопасность,  так  как  он  может  использовать  более  современные  механизмы  безопасности.

**Причины против переноса:**

* **Снижение  производительности:**  В  некоторых  случаях  компилируемый  код  может  быть  менее  производительным,  чем  хранимые  процедуры.
* **Увеличение  сложности  разработки:**  Перенос  бизнес-логики  из  хранимых  процедур  в  компилируемый  код  может  увеличить  сложность  разработки.
* **Проблемы  с  переносимостью:**  Компилируемый  код  может  быть  менее  переносимым,  чем  хранимые  процедуры.
* **Проблемы  с  поддержкой:**  Перенос  бизнес-логики  из  хранимых  процедур  в  компилируемый  код  может  усложнить  поддержку.
* **Проблемы  с  безопасностью:**  Компилируемый  код  может  увеличить  риски  безопасности,  если  он  не  написан  правильно.
* **Проблемы  с  интеграцией:**  Перенос  бизнес-логики  из  хранимых  процедур  в  компилируемый  код  может  усложнить  интеграцию  с  другими  системами.
