# Binding

**Binding** - это базовая концепция, которая используется практически в любом ASP.NET Core приложении, когда данные получаются от клиента (из форм, URL, JSON и т.д.) и передаются в action-методы контроллера.

Соответственно, понимание того, как данные связываются с моделями, необходимо для работы с остальными темами, такими как фильтры или обработка исключений.

В определенной степени такие темы как Binding, фильтры и обработка исключений взаимосвязаны:

- **Binding <-> Фильтры**: Валидационные фильтры часто работают на основе привязанных моделей. Они могут проверять данные модели перед выполнением действия контроллера и, например, возвращать ошибки валидации.
- **Фильтры <-> Обработка исключений**: Фильтры могут влиять на то, как обрабатываются исключения. Например, можно использовать фильтры для логирования исключений или для предоставления пользовательского ответа в случае ошибки.
- **Binding <-> Обработка исключений**: Ошибки при binding (например, если данные из запроса не могут быть преобразованы в нужный тип) также могут приводить к исключениям, которые нужно обрабатывать.

Взаимосвязь не всегда прямая и жесткая, но понимание всех трех концепций поможет создавать более надежные и поддерживаемые приложения. В контексте обработки и отображения ошибок связь этих тем становится более очевидной:

- **Binding**: Некорректные данные во время binding могут приводить к исключениям (например, `ModelStateException`). Важно уметь обрабатывать эти ошибки, показывая пользователю понятные сообщения об ошибках.
- **Фильтры**: Фильтры (например, `ExceptionFilter`) могут перехватывать необработанные исключения на уровне запроса. Они могут записывать исключения в логи или предоставлять пользователю дружелюбный ответ об ошибке.
- **Обработка исключений**: Это, безусловно, ключевой механизм. Исключения возникают при проблемах с данными (binding), при ошибках в бизнес-логике, при проблемах с БД. Нужно уметь перехватывать исключения, обрабатывать их (например, логировать) и предоставлять пользователю понятную обратную связь (например, вместо стектрейса).

Таким образом, все три темы вместе формируют механизм обработки ошибок. Связывание данных может порождать ошибки, фильтры могут их перехватывать, а обработка исключений - финально разрешать ситуацию и возвращать правильный ответ.

## Процесс преобразования данных из запроса в объекты .NET

Как этот процесс работает:

1. Получение запроса: ASP.NET Core получает HTTP-запрос, который включает в себя различные части:
    - URL (путь и параметры).
    - Заголовки.
    - Тело запроса (с данными, если есть).
    - Тип контента (например, `application/json`, `application/x-www-form-urlencoded`).
2. Определение источника данных (Binding Source):
    - ASP.NET Core анализирует, как данные должны быть привязаны к параметрам метода контроллера. Это может быть явно указано с помощью атрибутов, таких как `[FromRoute]`, `[FromQuery]`, `[FromBody]` и т.д., или неявно, полагаясь на соглашения.
    - **Default Binding**: ASP.NET Core выбирает источник данных по умолчанию, если атрибуты не указаны явно, в зависимости от типа параметра:
        - Простые типы (`string`, `int`, `bool` и т.д.):
            - Сначала ищет данные в URL (route).
            - Затем ищет данные в query string.
            - Не будет искать данные в теле запроса по умолчанию.
        - Сложные типы (классы и структуры):
            - Ищет данные в теле запроса (предполагая, что это JSON или форма, основанная на `Content-Type`).
            - Если не найдено в теле, то пробует связывание из формы.
3. Выбор Model Binder:
    - На основе источника данных и типа параметра, ASP.NET Core выбирает соответствующий Model Binder. Model Binder - это компонент, который ответственен за преобразование данных из определенного источника в объект .NET. Например, есть:
        - `FormValueProvider` для `[FromForm]`.
        - `QueryStringValueProvider` для `[FromQuery]`.
        - `JsonInputFormatter` для `[FromBody]` (если контент - JSON).
        - `RouteValueProvider` для `[FromRoute]`.
        - `HeaderValueProvider` для `[FromHeader]`.
4. Извлечение и преобразование данных:
    - Model Binder получает данные из соответствующего источника (например, из строки запроса, тела JSON и т.д.).
    - Binder преобразует данные к ожидаемому типу данных параметра метода контроллера. Это может включать в себя:
        - Преобразование строк в числа (`int`, `double`, и т.д.).
        - Преобразование строк в даты.
        - Преобразование JSON в объекты .NET.
        - Преобразование из `x-www-form-urlencoded` в параметры модели.
5. Создание объекта:
    - Если параметр метода контроллера является сложным типом (например, модель), то Model Binder создаёт экземпляр этого класса (или структуры) и заполняет его свойства, используя преобразованные данные.
6. Проверка ошибок:
    - Если преобразование или привязка данных не удаётся, Model Binder сохраняет информацию об ошибке в `ModelState`.
7. Передача объекта в действие контроллера:
    - После успешной привязки, данные передаются как аргумент в action method контроллера.

### Связывание со свойствами классов и структур

ASP.NET Core сопоставляет данные из запроса со свойствами классов и структур по именам.

- **Совпадение имен**: Если имя параметра или поля в запросе совпадает с именем свойства в классе, то ASP.NET Core автоматически свяжет их.
- **Case-Insensitive**: Сопоставление имен по умолчанию является нечувствительным к регистру.
    - **Удобство для разработчиков и клиентов**: Это делает разработку более простой и менее подверженной ошибкам. Клиенты могут случайно использовать разные регистры при передаче параметров.
    - **Общепринятая практика**: В веб-разработке регистронезависимый парсинг URL и параметров запроса - это обычная практика.
    - **Стандарты**: **RFC 3986 (URI)** говорит, что компоненты URI могут быть регистронезависимыми. Хотя **URI Path** не является регистронезависимым, но часть пути после `"?"` (query) является регистронезависимой.
- **Вложенные объекты**: ASP.NET Core может связывать данные с вложенными объектами, используя синтаксис с точками (например, `user.name`).
- **Коллекции**: ASP.NET Core может связывать данные с коллекциями (массивами, списками и т.д.), используя синтаксис с индексами (например, `items[0]`, `items[1]`).

### Отличия атрибутов `[Bind]`, `[ModelBinder]`, `[BindRequired]`, `[BindNever]`

- `[Bind]`:
    - Используется на уровне метода действия, класса или свойства.
    - Позволяет указать, какие свойства модели могут быть связаны, т.е. `[Bind]` работает как "список разрешений" для свойств модели: в записи `[Bind("Property1", "Property2")]` будут связаны только `Property1` и `Property2`. Все остальные свойства будут проигнорированы.
    - Ограничивает связывание только перечисленными свойствами (включает по умолчанию).
    - Полезно для защиты от массового назначения (mass assignment).

- `[ModelBinder]`:
    - Используется на уровне параметра метода действия, свойства или типа.
    - Указывает, какой именно Model Binder должен использоваться для связывания, давая более полный контроль.
    - Позволяет использовать кастомный Model Binder для сложной логики привязки.

- `[BindRequired]`:
    - Используется на уровне свойства.
    - Помечает свойство, как обязательное для связывания.
    - Если свойство не будет найдено в запросе, то будет ошибка валидации ModelState.

- `[BindNever]`:
    - Используется на уровне свойства.
    - Запрещает связывание данных со свойством.
    - Свойство будет исключено из процесса привязки (будет проигнорировано).

### Отслеживание ошибок валидации с помощью ModelState

- `ModelState` содержит информацию о состоянии привязки и валидации модели.
- Когда `ModelBinder` не может привязать данные или валидация проваливается, `ModelState` помечается как невалидная.
- Полезные случаи:
    - Отображение ошибок валидации в пользовательском интерфейсе.
    - Возврат ошибок валидации в API.
    - Предотвращение обработки невалидных данных.
- Как сымитировать:
    1. Создать модель с атрибутами валидации (например, `[Required]`).
    2. Создать контроллер, который связывает данные с этой моделью.
    3. Сделайте запрос, передав невалидные данные (например, не заполнив обязательное поле).
    4. Проверь, что `ModelState.IsValid` возвращает `false`.
    5. Используйте `ModelState.Errors` для получения ошибок.

## Примеры

### Упражнения, чтобы понять связывание данных с параметрами методов контроллера

1. **URL Parameters (`[FromRoute]`)**:

- Создать контроллер с действием, которое принимает параметр из URL:
```C#
[Route("api/[controller]/{id}")]
public class TestController : ControllerBase
{
    [HttpGet]
    public IActionResult Get(int id)
    {
        return Ok($"ID: {id}");
    }
}
```

- Запустите приложение и сделайте запрос: `GET /api/Test/123`. Убедитесь, что `id` передаётся правильно.
- Измените URL-путь и посмотрите на результат.

2. **Query String Parameters (`[FromQuery]`)**:

- Создать действие, которое принимает параметры из query string:
```C#
[Route("api/[controller]/query")]
public class TestController : ControllerBase
{
    [HttpGet("query")]
    public IActionResult GetQuery([FromQuery] string name, [FromQuery] int age)
    {
        return Ok($"Name: {name}, Age: {age}");
    }
}
```

- Сделайте запрос: `GET /api/Test/query?name=John&age=30`. Убедитесь, что `name` и `age` передаются правильно.
- Попробуйте пропустить один из параметров и посмотрите результат.

3. **Form Data (`[FromForm]`)**:

- Создать HTML-форму:
```html
<form method="post" action="/api/Test/form">
    <input type="text" name="username" />
    <input type="password" name="password" />
    <button type="submit">Submit</button>
</form>
```

- Создать действие, которое принимает данные из формы:
```C#
[Route("api/[controller]/form")]
public class TestController : ControllerBase
{
    [HttpPost("form")]
    public IActionResult PostForm([FromForm] string username, [FromForm] string password)
    {
        return Ok($"Username: {username}, Password: {password}");
    }
}
```

- Отправьте форму и посмотрите результат.

4. **JSON Body (`[FromBody]`)**:
- Создать модель:
```C#
public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
}
```

- Создать действие, которое принимает данные из тела запроса в формате JSON:
```C#
[Route("api/[controller]/json")]
public class TestController : ControllerBase
{
    [HttpPost("json")]
    public IActionResult PostJson([FromBody] User user)
    {
        return Ok($"Name: {user.Name}, Email: {user.Email}");
    }
}
```

- Сделайте запрос POST с JSON телом:
```JSON
{ "name": "John", "email": "john@example.com" }
```

- Используйте Postman или другой инструмент.

5. **Headers (`[FromHeader]`)**:

- Создать действие, принимающее значения из заголовка:
```C#
[Route("api/[controller]/header")]
public class TestController : ControllerBase
{
    [HttpGet("header")]
    public IActionResult GetHeader([FromHeader] string X-Custom-Header)
    {
        return Ok($"Custom Header: {X-Custom-Header}");
    }
}
```

- Установить заголовок `X-Custom-Header` и отправь запрос.

### Использование `[FromRoute]` для локали

Использование `[FromRoute]` для получения информации о локали из URL (например, `GET /en-GB/WeatherForecast`) - хороший подход, если есть необходимость, чтобы язык был явно указан в URL, а не полагаться исключительно на cookies. Это делает ссылки на приложение более "самостоятельными" и понятными для пользователя.

- Среди преимуществ такого подхода можно выделить:
- **SEO**: Поисковики могут лучше индексировать разные языковые версии.
- **Удобство**: Пользователь может напрямую переключаться между языками, изменяя URL.
- **Явность**:  Локаль явно видна в URL.

### Примеры задач для атрибутов валидации

- `[Required]`:
    - Требовать, чтобы поле было заполнено (например, имя пользователя).
    - `[Required(ErrorMessage = "Name is required.")]`
- `[StringLength]`:
    - Ограничивать максимальную и/или минимальную длину строки (например, пароль).
    - `[StringLength(100, MinimumLength = 6, ErrorMessage = "Password must be between 6 and 100 characters.")]`
- `[Range]`:
    - Ограничивать числовое значение в определенном диапазоне (например, возраст).
    - `[Range(18, 120, ErrorMessage = "Age must be between 18 and 120.")]`
- `[EmailAddress]`:
    - Проверять, что значение является действительным email адресом.
    - `[EmailAddress(ErrorMessage = "Invalid email address.")]`
- `[RegularExpression]`:
    - Проверять, что значение соответствует определенному регулярному выражению (например, номер телефона).
    - `[RegularExpression(@"^\d{3}-\d{3}-\d{4}$", ErrorMessage = "Invalid phone number format.")]`
- `[Compare]`:
    - Проверять, что два значения совпадают (например, подтверждение пароля).
    - `[Compare("Password", ErrorMessage = "Passwords do not match.")]`

### Вывод сообщений об ошибках в пользовательском интерфейсе

1. `ErrorMessage` в атрибутах:
    - Как уже было отмечено, можно выводить сообщения об ошибках, используя атрибут `ErrorMessage` в атрибутах валидации (например, `[Required(ErrorMessage = "Username is requried!")]`).
2. `ValidationSummary`:
    - Можно использовать `ValidationSummary` для вывода всех ошибок `ModelState` в одном месте на странице.
    - Можно настроить разные режимы отображения ошибок.
3. `ValidationMessage`:
    - Можно использовать `ValidationMessage` для вывода сообщений об ошибках для конкретного поля.
4. Custom Error Display:
    - Можно написать свой собственный хелпер или компонент, который будет читать ошибки из `ModelState` и выводить их в нужном формате.
    - Это полезно, если есть специфические требования к форматированию ошибок.
5. API Responses:
    - Для API, можно использовать `ModelState.Errors`, чтобы вернуть JSON ответ с ошибками валидации.
