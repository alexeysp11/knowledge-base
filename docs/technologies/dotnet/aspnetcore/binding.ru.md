# Binding

**Binding** - это базовая концепция, которая используется практически в любом ASP.NET Core приложении, когда ты получаешь данные от клиента (из форм, URL, JSON и т.д.) и передаешь их в свои действия контроллера. Понимание того, как данные связываются с моделями, необходимо для работы с остальными темами, такими как фильтры или обработка исключений.

В определенной степени такие темы как Binding, фильтры и обработка исключений взаимосвязаны:

- **Binding <-> Фильтры**: Валидационные фильтры часто работают на основе привязанных моделей. Они могут проверять данные модели перед выполнением действия контроллера и, например, возвращать ошибки валидации.
- **Фильтры <-> Обработка исключений**: Фильтры могут влиять на то, как обрабатываются исключения. Например, можно использовать фильтры для логирования исключений или для предоставления пользовательского ответа в случае ошибки.
- **Binding <-> Обработка исключений**: Ошибки при binding (например, если данные из запроса не могут быть преобразованы в нужный тип) также могут приводить к исключениям, которые нужно обрабатывать.

Взаимосвязь не всегда прямая и жесткая, но понимание всех трех концепций поможет создавать более надежные и поддерживаемые приложения. В контексте обработки и отображения ошибок связь этих тем становится более очевидной:

- **Binding**: Некорректные данные во время binding могут приводить к исключениям (например, ModelStateException). Важно уметь обрабатывать эти ошибки, показывая пользователю понятные сообщения об ошибках.
- **Фильтры**: Фильтры (например, ExceptionFilter) могут перехватывать необработанные исключения на уровне запроса. Они могут записывать исключения в логи или предоставлять пользователю дружелюбный ответ об ошибке.
- **Обработка исключений**: Это, безусловно, ключевой механизм. Исключения возникают при проблемах с данными (binding), при ошибках в бизнес-логике, при проблемах с БД. Нужно уметь перехватывать исключения, обрабатывать их (например, логировать) и предоставлять пользователю понятную обратную связь (например, вместо стектрейса).

Таким образом, все три темы вместе формируют твой механизм обработки ошибок. Связывание данных может порождать ошибки, фильтры могут их перехватывать, а обработка исключений - финально разрешать ситуацию и возвращать правильный ответ.

## Процесс преобразования данных из запроса в объекты .NET:

Как этот процесс работает:

1. Получение запроса: ASP.NET Core получает HTTP-запрос, который включает в себя различные части:
    - URL (путь и параметры).
    - Заголовки.
    - Тело запроса (с данными, если есть).
    - Тип контента (например, `application/json`, `application/x-www-form-urlencoded`).
2. Определение источника данных (Binding Source):
    - ASP.NET Core анализирует, как данные должны быть привязаны к параметрам метода контроллера. Это может быть явно указано с помощью атрибутов, таких как `[FromRoute]`, `[FromQuery]`, `[FromBody]` и т.д., или неявно, полагаясь на соглашения.
3. Выбор Model Binder:
    - На основе источника данных и типа параметра, ASP.NET Core выбирает соответствующий Model Binder. Model Binder – это компонент, который ответственен за преобразование данных из определенного источника в объект .NET. Например, есть:
        - `FormValueProvider` для `[FromForm]`.
        - `QueryStringValueProvider` для `[FromQuery]`.
        - `JsonInputFormatter` для `[FromBody]` (если контент - JSON).
        - `RouteValueProvider` для `[FromRoute]`.
        - `HeaderValueProvider` для `[FromHeader]`.
4. Извлечение и преобразование данных:
    - Model Binder получает данные из соответствующего источника (например, из строки запроса, тела JSON и т.д.).
    - Binder преобразует данные к ожидаемому типу данных параметра метода контроллера. Это может включать в себя:
        - Преобразование строк в числа (`int`, `double`, и т.д.).
        - Преобразование строк в даты.
        - Преобразование JSON в объекты .NET.
        - Преобразование из `x-www-form-urlencoded` в параметры модели.
5. Создание объекта:
    - Если параметр метода контроллера является сложным типом (например, модель), то Model Binder создаёт экземпляр этого класса (или структуры) и заполняет его свойства, используя преобразованные данные.
6. Проверка ошибок:
    - Если преобразование или привязка данных не удаётся, Model Binder сохраняет информацию об ошибке в `ModelState`.
7. Передача объекта в действие контроллера:
    - После успешной привязки, данные передаются как аргумент в метод действия (action method) контроллера.

### Связывание со свойствами классов и структур:

ASP.NET Core сопоставляет данные из запроса со свойствами классов и структур по именам.

- **Совпадение имен**: Если имя параметра или поля в запросе совпадает с именем свойства в классе, то ASP.NET Core автоматически свяжет их.
- **Case-Insensitive**: Сопоставление имен по умолчанию является нечувствительным к регистру.
    - **Удобство для разработчиков и клиентов**: Это делает разработку более простой и менее подверженной ошибкам. Клиенты могут случайно использовать разные регистры при передаче параметров.
    - **Общепринятая практика**: В веб-разработке регистронезависимый парсинг URL и параметров запроса - это обычная практика.
    - **Стандарты**: RFC 3986 (URI) говорит, что компоненты URI могут быть регистронезависимыми. Хотя URI Path не является регистронезависимым, но часть пути после `"?"` (query) является регистронезависимой.
- **Вложенные объекты**: ASP.NET Core может связывать данные с вложенными объектами, используя синтаксис с точками (например, `user.name`).
- Коллекции: ASP.NET Core может связывать данные с коллекциями (массивами, списками и т.д.), используя синтаксис с индексами (например, `items[0]`, `items[1]`).

### Отличия атрибутов `[Bind]`, `[ModelBinder]`, `[BindRequired]`, `[BindNever]`:

- `[Bind]`:
    - Используется на уровне метода действия, класса или свойства.
    - Позволяет указать, какие свойства модели могут быть связаны, т.е. `[Bind]` работает как "список разрешений" для свойств модели: в записи `[Bind("Property1", "Property2")]` будут связаны только `Property1` и `Property2`. Все остальные свойства будут проигнорированы.
    - Ограничивает связывание только перечисленными свойствами (включает по умолчанию).
    - Полезно для защиты от массового назначения (mass assignment).

- `[ModelBinder]`:
    - Используется на уровне параметра метода действия, свойства или типа.
    - Указывает, какой именно Model Binder должен использоваться для связывания, давая более полный контроль.
    - Позволяет использовать кастомный Model Binder для сложной логики привязки.

- `[BindRequired]`:
    - Используется на уровне свойства.
    - Помечает свойство, как обязательное для связывания.
    - Если свойство не будет найдено в запросе, то будет ошибка валидации ModelState.

- `[BindNever]`:
    - Используется на уровне свойства.
    - Запрещает связывание данных со свойством.
    - Свойство будет исключено из процесса привязки (будет проигнорировано).

### Отслеживание ошибок валидации с помощью ModelState:

- `ModelState` содержит информацию о состоянии привязки и валидации модели.
- Когда `ModelBinder` не может привязать данные или валидация проваливается, `ModelState` помечается как невалидная.
- Полезные случаи:
    - Отображение ошибок валидации в пользовательском интерфейсе.
    - Возврат ошибок валидации в API.
    - Предотвращение обработки невалидных данных.
- Как сымитировать:
    1. Создай модель с атрибутами валидации (например, `[Required]`).
    2. Создай контроллер, который связывает данные с этой моделью.
    3. Сделай запрос, передав невалидные данные (например, не заполнив обязательное поле).
    4. Проверь, что `ModelState.IsValid` возвращает `false`.
    5. Используй `ModelState.Errors` для получения ошибок.
