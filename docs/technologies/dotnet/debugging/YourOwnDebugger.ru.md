# Написание собственного отладчика для приложений .NET Core

## Изучение существующих решений

- GDB
- dnSpy

## Определение функциональности отладчика

- Установка точек останова
- Просмотр локальных переменных внутри метода, а также полей/свойств текущего объекта.
- Получения стек вызовов.

## Подходы к отладке приложений с точки зрения внутренней реализации

1. Отладка на уровне исходного кода: Этот подход включает в себя использование информации о строках исходного кода и их соответствия IL-коду. Обычно это достигается через PDB-файлы (Program Database), которые содержат информацию о символах и отладочных данных.

2. Отладка на уровне IL: Этот подход включает в себя анализ Intermediate Language (IL) кода. Можно использовать такие инструменты, как [Mono.Cecil](https://github.com/jbevain/cecil), для анализа и модификации IL-кода.

- Изучение формата IL: Начни с изучения формата IL и структуры .NET-метаданных. Это поможет понять, как работает код и как его можно модифицировать.
- Использование [Mono.Cecil](https://github.com/jbevain/cecil): Эта библиотека позволяет читать и изменять .NET-ассембли. С ее помощью можно анализировать IL-код и вставлять дополнительные инструкции.
- Создание точки входа: Стоит определить, как отладчик будет взаимодействовать с исполняемой программой. Это может быть сделано через загрузку динамически созданного кода или через внедрение в существующий процесс.
- Работа с PDB-файлами: Изучение PDB-файлов может помочь сопоставить IL-код с исходным кодом, что облегчит установку точек останова и просмотр переменных.

3. Инструментальная отладка: Этот метод основан на использовании инструментов для вмешательства в выполнение программы (например, Windows Debugging API или ptrace в Linux). Это позволяет устанавливать точки останова и получать информацию о состоянии приложения во время его выполнения.

4. Анализ состояния памяти: Некоторые отладчики используют анализ состояния памяти для определения значений переменных и других данных во время выполнения программы.

5. Подход на основе перекомпиляции кода: в момент компиляции/выполнения преобразуем код, чтобы на каждой строчке каждого метода был код, который определяет, есть ли точка останова на конкретной строчке и отображает все необходимые значения.

- Изменение IL-кода: можно модифицировать IL-код во время компиляции, добавляя инструкции для проверки точек останова. Например, можно вставить код, который будет проверять наличие точки останова перед выполнением каждой строки кода
- Использование Roslyn: можно использовать Roslyn для анализа и модификации кода на этапе компиляции. Это позволит добавлять необходимые конструкции в код.
- Управление состоянием: нужно будет разработать механизм для хранения и управления состоянием точек останова, а также для взаимодействия с пользователем (например, через консоль или GUI).

6. Атрибуты для имитации машины состояний: Использование атрибутов для того, чтобы при компиляции преобразовывать методы конкретного класса в объекты, похожие на машину состояний, которая имеет возможность останавливать код с помощью точек останова.

## Идеи по реализации

### Установка точек останова

Если речь идет про отладку консольных приложений, то возможно поставить точку останова следующим образом:
- Запускаем отладчик.
- Указываем `csproj` файл для компиляции.
- Указываем имя файла и номер строки для точки остановаю
- В рамках проекта внутри каждого метода на каждой строчке ставим конструкцию/метод для имитации точки останова.
- В момент выполнения кода проверяем укзана ли точка останова в начале программы для конкретной строчки.
- Для того, чтобы сопоставлять оригинальный код с измененным, содержащим точки останова, сделать `Dictionary`.

При отладке приложений, не являющихся консольными, стоит определить, как отладчик будет взаимодействовать с исполняемой программой. Это может быть сделано через загрузку динамически созданного кода или через внедрение в существующий процесс. Возможные варианты решений:

- Реализовать механизм инъекции кода в существующий процесс, используя такие технологии, как `AppDomain` или `Assembly.Load`, чтобы динамически подгружать и выполнять код.
- Использовать библиотеки, такие как Mono.Cecil, для изменения промежуточного языка (IL) на лету, добавляя инструкции для точек останова.
- Внедрить код в процесс через вызовы Windows API, такие как `CreateRemoteThread` и `VirtualAllocEx`, чтобы установить точки останова в исполняемом коде.

### Получение локальных переменных

Получение значений локальных переменных в текущем методе может быть труднореализуемой, т.к. рефлексия позволяет получить, по большому счету, только тип объекта.

Однако можно с помощью рефлексии получить приватные/публичные поля или свойства объекта. Также в .NET асинхронные методы под капотом преобразуются в объект машины состояний, у которого все локальные переменные становятся полями объекта, а весь метод делится на части по количеству `await`.

Подобную идею можно попробовать использовать при отладке: преобразовать метод в объект машины состояний и получать все переменные, которые были локальными, как поля объекта с помощью рефлексии.

Основной проблемой при данном подходе может быть работа с асинхронными методами, т.к. они тоже преобразуются в машину состояний, и хорошо бы сделать так, чтобы с одной стороны "не изобретать велосипед", а с другой стороны внедрить в сгенерированную машину состояний собственные конструкции для отладки. Возможные решения:

- Вставить вспомогательные методы в сгенерированную машину состояний, которые будут управлять состоянием выполнения и точками останова.
- При выполнении преобразования кода, не переводить асинхронный метод в машину состояний, а просто вставлять методы для точек останова.
