# TcpServiceNetCore

[English](README.md) | [Русский](README.ru.md)

Если ваш проект уже использует TCP и хорошо протестирован, то использование `IHostedService` с TCP будет более быстрым решением для доработки. Это позволит вам сохранить существующую инфраструктуру и минимизировать риски, связанные с изменениями.

Однако, если в будущем вы планируете масштабировать сервис и хотите обеспечить возможность обработки запросов без необходимости поддерживать постоянное соединение, тогда стоит рассмотреть использование gRPC или WebAPI. Эти технологии предлагают более высокоуровневые абстракции, которые упрощают разработку, тестирование и поддержку.

## Тестирование

### Подход 1: Создание приложения на C# для коммуникации по TCP

Вы можете создать простое консольное приложение на C#, которое будет подключаться к вашему TCP-серверу, отправлять запросы и получать ответы.

### Подход 2: Использование Telnet

Telnet - это простой способ взаимодействия с TCP-сервером через командную строку. Чтобы использовать Telnet для тестирования вашего сервиса:

1. Убедитесь, что Telnet установлен на вашей системе (в Windows может потребоваться включить его через "Программы и компоненты").

2. Откройте командную строку (cmd) и введите команду:

```bat
telnet 127.0.0.1 5000
```

Здесь `127.0.0.1` - это адрес вашего сервера, а `5000` - порт, на котором он слушает.

3. После подключения вы можете вводить текстовые команды и отправлять их на сервер. Например, введите:

```
Hello Server!
```

Нажмите Enter, чтобы отправить сообщение.

4. Если ваш сервер настроен на отправку ответов, вы увидите их в окне Telnet.

## Требования

### Серверное приложение

Приложение должно обладать следующим фукнционалом:
- [x] С клиента идет TCP-запрос к сервису; сервис обрабатывает запрос и инициирует TCP-соединение.
- [x] Приложение может обрабатывать несколько запросов одновременно.
- [x] Соединение остается постоянным на протяжении всей сессии.
- [ ] Коммуникация в рамках сессии производится в следующем виде:
    - [ ] Клиент набирает текст, нажимает Enter, и отправляет новый TCP-запрос на сервис. Сообщение не считается отправленным, пока не был нажат Enter; при нажатии на Escape текущая операция отменяется.
    - [ ] В процессе обработки запроса сервис формирует и отправляет некую текстовую информацию в виде двумерного массива символов заданного размера (например, 26 в ширину и 16-18 в высоту).
    - [ ] Затем цикл повторяется: клиент набирает сообщение, нажимает Enter, а потом сервис его обрабатывает.
- [ ] Все данные, находящиеся в TCP-запросах и TCP-ответах, автоматически приводит к верхнему регистру.
- [ ] Контролы делятся на следующие типы: текстовое поле отображения `TextControl`, текстовое поле ввода `TextEditControl`. Допускается наследоваться от указанных полей и создавать контролы для специализированных нужд (например, ввод пароля, ввод товара с кастомной валидацией). Также допускается определять методы для валидации как делегаты (делегаты будут вызываться в теле метода, выполняющего валидацию; имя метода валидации в контроле начинается с `On`).
    - [ ] Текстовое поле отображения `TextControl`:
        - **Наследование**: является базовым.
        - **Поля**: наименование `Name`, координаты `X` и `Y`, ширина `Width`, значение `Value`, видимый `Visible`, выравнивание по горизонтали `HorizontalAlignment`, инвертирование `Inverted`.
        - **Валидация**: валидация перед отображением `ShowValidation` (отображает поле, если оно видимое).
    - [ ] Текстовое поле ввода `TextEditControl`:
        - **Наследование**: наследуется от `TextControl`.
        - **Поля**: обязательно для заполнения `Required`, `Hint` (подсказка для ввода внизу формы).
        - **Валидация**: валидация перед отображением `ShowValidation` (отображает поле, если оно видимое, также отображает подсказку); валидация перед отображением `RequireValidation` (допускает ввод значений в поле, если оно обязательно для заполнения); валидация ввода `EnterValidation`.
- [ ] На форме в методе `InitializeComponent` определяются и регистрируются все контролы, а также свойства этих контролов.
- [ ] Есть базовая форма `BaseForm`, которая отображает и обрабатывает контролы: отображение производится сверху вниз и слева направо.
- [ ] Есть класс `MenuFormResolver` для работы с пунктами меню, который выполняет следующие операции:
    - [ ] Принимает на вход код операции (например, `0-0-1`, `0-0-2`, `1-0-3`, etc).
    - [ ] По коду операции создает экземпляр формы.
    - [ ] Заполняет атрибуты формы.
    - [ ] Вызывает методы `Init()` и `Show()` у формы.

Пример отображения информации представлен ниже:
```
    TCP SERVICE
TEST TCP CONNECTION

REQUEST NUMBER: 1
REQUEST BODY:
..........................
..........................
..........................

RESPONSE BODY:
..........................
..........................
..........................

ENTER REQUEST BODY
```

### Клиентское приложение

- [ ] Для TCP сервиса лучше написать кастомный клиент для взаимодействия из командной строки. Таким образом, будут следующие компоненты:
    - [ ] Библиотека сетевого взаимодействия `ClientAdapter`: коммуницирует с сервисом по TCP и возвращает двумерный массив символов.
    - [ ] Консольное приложение: не затирает команды, которые отображались ранее; имеет область, в которой отображает информацию; каждый раз после получения ответа от сервиса очищает область отображения.
